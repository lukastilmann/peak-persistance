% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/find_max_lambda.R
\name{find_max_lambda}
\alias{find_max_lambda}
\title{Find First Lambda Value Where Frobenius Norm of Difference
Between Inelastic and Elastic Mean Drops Below Threshold}
\usage{
find_max_lambda(
  function_curves,
  start_val = 2,
  threshold = 0.01,
  min_bound = 0.001,
  max_iter = 10,
  penalty = "roughness",
  max_search_steps = 20,
  parallel = FALSE
)
}
\arguments{
\item{function_curves}{An object containing functional data. Can be either:
(1) a data frame containing a 'curves' column that is a tidyfun 'tfd' object, or
(2) a tidyfun 'tfd' object directly.}

\item{start_val}{Numeric. Initial lambda value to test (default = 2).}

\item{threshold}{Numeric. The threshold value for the Frobenius norm below which
a lambda value is considered acceptable (default = 1e-2).}

\item{min_bound}{Numeric. Minimum distance between upper and lower bounds for
search termination (default = 1e-3).}

\item{max_iter}{Integer. Maximum number of iterations for the alignment algorithm
(default = 10). Will be doubled if initial convergence fails.}

\item{penalty}{character. Specifies penalty used in function alignment.}

\item{max_search_steps}{Integer. Maximum number of binary search steps to perform
(default = 20).}

\item{parallel}{Logical. Whether to use parallel processing for alignment
(default = FALSE).}
}
\value{
Numeric. The lowest lambda value where the Frobenius norm of the
difference between the inelastic and elastic mean functions is below
the specified threshold.
}
\description{
This function determines the optimal regularization parameter (lambda) for
function alignment by finding the lowest lambda value where the Frobenius norm
of the difference between inelastic and elastic mean functions drops below a
specified threshold. It employs a binary search (divide and conquer) approach
to efficiently identify this value.
}
\details{
The function first checks if the provided starting lambda value yields a
Frobenius norm below the threshold. If not, it searches for an upper bound
by doubling lambda until finding a value that satisfies the threshold.

Once appropriate bounds are established, a binary search is conducted to refine
the lambda value, seeking the lowest value that still satisfies the threshold
criterion. This approach efficiently navigates the trade-off between alignment
quality and regularization strength.

The Frobenius norm is normalized by the square root of the sum of squared
deviations of the inelastic mean from its average value, providing a relative
measure of improvement.

If the alignment algorithm fails to converge with the initial max_iter value,
the function will automatically double max_iter and retry once before warning
the user.
}
\examples{
\dontrun{
library(tidyfun)

# Create synthetic functional data
t_grid <- seq(0, 1, length.out = 100)
curves_data <- replicate(10, sin(2 * pi * t_grid + rnorm(1, 0, 0.5)))
tf_curves <- tf_spline(curves_data, arg = t_grid)

# Direct tfd object input
optimal_lambda1 <- find_max_lambda(
  function_curves = tf_curves,
  start_val = 2,
  threshold = 0.01
)

# In a data frame
data_with_curves <- data.frame(id = 1)
data_with_curves$curves <- tf_curves
optimal_lambda2 <- find_max_lambda(
  function_curves = data_with_curves,
  start_val = 2,
  threshold = 0.01
)

print(paste("Optimal lambda value:", optimal_lambda1))
}

}

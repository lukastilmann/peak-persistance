% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/align_functions.R
\name{align_functions}
\alias{align_functions}
\title{Align Functional Data Objects}
\usage{
align_functions(
  fun_curves,
  lambda = 0,
  parallel = FALSE,
  max_iter = 10,
  penalty = "roughness",
  t_grid = NULL,
  verbosity = "low"
)
}
\arguments{
\item{fun_curves}{A functional data object (inheriting from class \code{tf}) or
a data frame with exactly one column that inherits from \code{tf}.}

\item{lambda}{Numeric value specifying the regularization parameter.
Controls the smoothness of the warping functions. Default is 0.0.}

\item{parallel}{Logical indicating whether to use parallel processing.
Default is FALSE.}

\item{max_iter}{Integer specifying the maximum number of iterations.
Default is 10.}

\item{penalty}{Character string specify which penalty is used for function
alignment.}

\item{t_grid}{Numeric vector of time points for evaluation. If NULL (default),
the function will use the evaluation grid from the input object.}

\item{verbosity}{Character string specifying the level of progress messages.
Must be either "low" or "high". Default is "low".}
}
\value{
A list containing three elements:
\item{aligned_curves}{A \code{tfd} object containing the aligned curves}
\item{warping_functions}{A \code{tfd} object containing the warping functions}
\item{converged}{Logical indicating whether the algorithm converged}
}
\description{
Performs alignment of functional data by finding time warping functions
that minimize a fitting criterion. This function serves as a wrapper for
the \code{time_warping} function with additional input validation and
user-friendly messaging.
}
\details{
The function aligns functional data using the Fisher-Rao metric and
square-root velocity framework. The alignment is performed by finding
time warping functions that minimize a criterion balancing data fit and
smoothness of the warping functions. The parameter \code{lambda} controls
this trade-off.
}
\examples{
\dontrun{
# Create some sample functional data
data <- tfd(matrix(rnorm(500), nrow=5), arg=seq(0, 1, length.out=100))

# Align the curves
aligned <- align_functions(data, lambda=0.1)

# Plot original vs aligned curves
par(mfrow=c(1,2))
plot(data, main="Original curves")
plot(aligned$aligned_curves, main="Aligned curves")
}

}

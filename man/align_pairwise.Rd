% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/align_pairwise.R
\name{align_pairwise}
\alias{align_pairwise}
\title{Align a Function to Another Using SRVF Methodology}
\usage{
align_pairwise(function_1, function_2, t_grid = NULL, lambda = 0)
}
\arguments{
\item{function_1}{An object of class 'tf' representing the first function to be used as reference.
Must contain exactly one function.}

\item{function_2}{An object of class 'tf' representing the second function to be aligned to the first.
Must contain exactly one function.}

\item{t_grid}{A numeric vector specifying the time grid over which to perform the alignment.
If NULL (default), the time grid from function_1 will be used.}

\item{lambda}{A non-negative numeric value controlling the amount of regularization in the
alignment process. Higher values result in smoother warping functions. Default is 0.}
}
\value{
A list containing four components:
\item{function_2_aligned}{A 'tf' object representing function_2 after alignment to function_1}
\item{warping_function}{A 'tf' object representing the warping function that transforms function_2}
\item{q_1}{A 'tf' object containing the SRVF of function_1}
\item{q_2_aligned}{A 'tf' object containing the SRVF of function_2 after alignment}
}
\description{
Aligns one functional object to another using the Square Root Velocity Function (SRVF) framework.
This function performs temporal alignment (warping) to find the optimal time transformation
that makes the two functions as similar as possible while preserving shape characteristics.
}
\details{
The function uses the Square Root Velocity Function (SRVF) framework from the fdasrvf package
to find optimal time-warping. The alignment process finds a warping function that minimizes
the distance between the SRVFs of the two functions, with an optional regularization term
controlled by lambda. The Dynamic Programming algorithm is used for optimization.
}
\examples{
\dontrun{
# Create two example tf objects
t <- seq(0, 1, length.out = 100)
f1 <- tfd(sin(2*pi*t), t)
f2 <- tfd(sin(2*pi*t + 0.5), t)

# Align f2 to f1
result <- align_to_mean(f1, f2, lambda = 0.1)

# Plot the results
plot(f1, col = "black", main = "Alignment Result")
lines(f2, col = "red")
lines(result$function_2_aligned, col = "blue")
}

}
\seealso{
\code{\link[fdasrvf]{f_to_srvf}}, \code{\link[fdasrvf]{warp_f_gamma}}
}
